路由一个文档到一个分片中
1.shard = hash(routing) % number_of_primary_shards==>routing默认是ducument ID,这样保存和查询文档
2.主分片数量是固定的会使索引难以进行扩容。实际上当你需要时有很多技巧可以轻松实现扩容。
3.API（ get 、 index 、 delete 、 bulk 、 update 以及 mget ）都接受一个叫做 routing==>自定化扩容需求


协调节点
每个节点都知道集群中任一文档位置，所以可以直接将请求转发到需要的节点上


新建、索引和删除 请求都是 （写操作）
1.客户端向 Node 1 发送新建、索引或者删除请求。
2.节点使用文档的 _id 确定文档属于分片 0`。请求会被转发到 `Node 3`，因为分片 0 的主分片目前被分配在 `Node 3 上。
3.Node 3 在主分片上面执行请求。如果成功了，它将请求并行转发到 Node 1 和 Node 2 的副本分片上。一旦所有的副本分片都报告成功, Node 3 将向协调节点报告成功，协调节点向客户端报告成功。

取回单个文档(读操作)
1、客户端向 Node 1 发送获取请求。
2、节点使用文档的 _id 来确定文档属于分片 0 。分片 0 的副本分片存在于所有的三个节点上。 在这种情况下，它将请求转发到 Node 2 。
3、Node 2 将文档返回给 Node 1 ，然后将文档返回给客户端。
为了读取请求，协调节点在每次请求的时候将选择不同的副本分片来达到负载均衡；通过轮询所有的副本分片。


局部更新文档(读取和写入模式)
1.客户端向 Node 1 发送更新请求。
2.它将请求转发到主分片所在的 Node 3 。
3.Node 3 从主分片检索文档，修改 _source 字段中的 JSON ，并且尝试重新索引主分片的文档。 如果文档已经被另一个进程修改，它会重试步骤 3 ，超过 retry_on_conflict 次后放弃。
4.如果 Node 3 成功地更新文档，它将新版本的文档并行转发到 Node 1 和 Node 2 上的副本分片，重新建立索引。 一旦所有副本分片都返回成功， Node 3 向协调节点也返回成功，协调节点向客户端返回成功。



多文档模式
mget
1.客户端向 Node 1 发送 mget 请求。
2.Node 1 为每个分片构建多文档获取请求，然后并行转发这些请求到托管在每个所需的主分片或者副本分片的节点上。一旦收到所有答复， Node 1 构建响应并将其返回给客户端。

bulk
1.客户端向 Node 1 发送 bulk 请求。
2.Node 1 为每个节点创建一个批量请求，并将这些请求并行转发到每个包含主分片的节点主机。
3.主分片一个接一个按顺序执行每个操作。当每个操作成功时，主分片并行转发新文档（或删除）到副本分片，然后执行下一个操作。 一旦所有的副本分片报告所有操作成功，该节点将向协调节点报告成功，协调节点将这些响应收集整理并返回给客户端。